/*


给定一个整数，编写一个算法将这个数转换为十六进制数。对于负整数，我们通常使用 补码运算 方法。

注意:

    十六进制中所有字母(a-f)都必须是小写。

    十六进制字符串中不能包含多余的前导零。

    如果要转化的数为0，那么以单个字符'0'来表示；
    对于其他情况，十六进制字符串中的第一个字符将不会是0字符。 

    给定的数确保在32位有符号整数范围内。

    不能使用任何由库提供的将数字直接转换或格式化为十六进制的方法。

示例 1：

输入:
26

输出:
"1a"

示例 2：

输入:
-1

输出:
"ffffffff"


*/


//  数字模拟
class Solution {
    public String toHex(int _num) {
    	// 为了解决负数的问题 ， 用long
    	/*
    	CSAPP第一章有介绍2’s Comp. -> Unsigned，也就是用Unsigned的大正数表示Signed负数。

    	举个例子，8位int中-1表示为0b11111111(T)，无符号整数0b11111111(U)表示为2^8 - 1，
    	二者在计算机中二进制表示相同，差值为2^8。

    	因此先在负数的基础上加上2^8即可转化为一个大正数，二者的二进制表示相同。

    	在这里32位整形则将原始负数num加上2^32先转换成大正数，以无符号整形表示。

    	该无符号整形与原始有符号负数的2进制标是是一样的。
    	*/
    	long num = _num;
    	if (num == 0) return "0";
    	if (num < 0) {
    		// 加法会默认为int, 必须强转为long
    		num = (long)(Math.pow(2,32) + num);
    	}
    	StringBuilder sb = new StringBuilder();
    	while (num != 0){
    		// 这里只能用long，相同类型
    		long n = num % 16;
    		if (n < 10){
    			sb.append((char)(n + '0'));
    		} else {
    			char c = (char)(n - 10 +'a');
    			sb.append(c);
    		}
    		num /= 16;
    	}
    	return String.valueOf(sb.reverse());
    }
}


/*

首先，我们可以利用通用的进制转换思路来做，不断循环 num % k 和 num / k 的操作来构造出 k 进制每一位。

但需要处理「补码」问题：对于负数的 num，我们需要先在 num 基础上加上 2^32 的偏移量，再进行进制转换。

*/